---
layout: single
title: "JAVA 기초"
permalink: /seven/
categories:
  - JAVA
toc: true
toc_sticky: true
---

변수와 타입
==========

변수
----
<h4>변수(Variable) : 값이 변할 수 있는 데이터를 임시적으로 저장하기 위한 수단</h4>

프로그래밍은 데이터를 어떻게 처리할 것인가를 컴퓨터가 인지할 수 있는 언어로 작성하는 것을 의미합니다. <br>
어떤 데이터를 프로그래머가 원하는대로 처리하기 위해서는 그 데이터를 임시적으로 컴퓨터에 저장해둘 필요가 있습니다. <br>

|메모리|아파트|
|--------|------|
|메모리셀의 집합체|집의 집합체|
|각 메모리셀에 데이터를 저장할 수 있다.|각 집에 사람이 들어가 살 수 있다.|
|각 메모리셀을 가리키는 주소가 있다.|각 집을 가리키는 호수가 있다.|

메모리에 값을 저장할 수 있고, 값이 저장된 위치를 알고 있다면 그 값을 꺼내서 사용해야합니다. <br>
메모리에 값을 넣기 위해서는 메모리 주소에 직접 값을 넣어주어야 합니다. <br>

<h4>변수의 선언과 할당</h4>

<h5>변수 선언</h5>
변수를 사용하려면 먼저 변수를 선언하여야 합니다. <br>
변수를 선언할 때에는 저장하고자 하는 값의 데이터 타입과 함께 변수 이름을 작성해주면 됩니다. <br>

<pre>
    <code>
        class Example {
            public static void main(String[] args) {
                int num; // 변수 선언
            }
       }
    </code>
</pre>

이제 num 이라는 변수에 정수형의 숫자를 저장할 수 있게 되었습니다. <br>
지금부터는 변수를 선언하면 내부적으로 어떤 일이 발생하는지 살펴보겠습니다. <br>
<br>
**컴퓨터에 저장할 수 있는 값은 여러 가지 종류로 나뉘는데, 이러한 값의 종류를 타입이라고 하며, 여러 타입들 중에는 int형이라는 <br>
타입이 있습니다. 이 int 형은 4byte의 메모리 공간을 차지합니다.**
<br>
컴퓨터가 어떤 값을 저장하려면 먼저 값을 저장할 메모리 공간을 확보하고, <br>
추후에 그 값을 사용할 수 있도록 값이 저장된 공간에 이름을 붙여야 합니다. <br>
이 과정이 바로 변수를 선언했을 때 발생하는 과정입니다. <br>
**즉, 변수를 선언하면 컴퓨터는 값을 저장할 메모리 공간을 확보하고, 확보한 메모리 공간에 사용자가 입력한 변수 이름으로 이름을 붙입니다. ** <br>
** 변수 num은 int형이다. → int형은 4byte다. → 따라서 4byte의 메모리 공간을 확보해야 한다. **

<h5>값 할당</h5>
변수에 값을 저장하는 것을 **할당**또는 **대입**이라고 합니다. 변수에 값을 할당하는 방법은 간단합니다. <br>
**대입 연산자** = 을 아래 예제와 같이 활용하면 됩니다. 

<pre>
    <code>
        class Example {
            public static void main(String[] args) {
                int num; // 변수 선언
                num = 1; // 값 할당
            }
        }
    </code>
</pre>

위 예제에서, num에 1을 할당했으며, num을 선언하고 나서 처음으로 할당이 이루어졌습니다. 이처럼, 변수를 선언하고 나서 처음으로 값을 할당하는 것을 <br>
**초기화**라고 합니다. 그리고, 초기화가 이루어진 후에 다시 다른 값을 할당하는 것을 **재할당**이라고 합니다. <br>
<br>
아래 예시처럼 num을 1로 초기화한 후, 2로 재할당하면 num에 저장되어 있던 1은 사라지고 2가 저장됩니다.

<pre>
    <code>
        class Example {
            public static void main(String[] args) {
                int num; // 변수 선언
                num = 1; // 값 할당(초기화)
                num = 2; // 값 할당(재할당)
            }
        }
    </code>
</pre>

마지막으로, 변수를 선언하면서 동시에 초기화할 수도 있습니다.

<pre>
    <code>
        class Example {
            public static void main(String[] args) {
                int num = 1; // 선언과 동시에 초기화
            }
        }
    </code>
</pre>

<h4>변수 명명 규칙</h4>

자바에서 변수명은 일반적으로 카멜 케이스(camelCase)를 사용합니다. 카멜케이스란 낙타 등 모양을 닮았다고 해서 붙여진 이름으로, <br>
두번째 단어부터 대문자로 시작해 구분합니다. <br>
<br>
변수명으로 영문자, 숫자, _, $를 사용할 수 있으며, 영문자는 대소문자가 구별되어 인식됩니다. <br>
즉 a와 A는 다른 문자로 인식됩니다.

<pre>
    <code>
        // 아래의 모든 변수의 변수명은 허용되는 변수명입니다. 
        int num;
        int NUM; // num과 다른 변수입니다. 
        int num_1;
        int num$1;
        // 숫자로 시작하는 변수명은 사용할 수 없습니다.
        int 10Age; // Error 
        //자바에서 이미 사용 중인 예약어(reserved word)는 변수명으로 사용할 수 없습니다.
        int byte;  // Error
        int class; // Error
    </code>
</pre>

상수
----

<h4>상수(Constant) : 변하지 말아야 할 데이터를 임시적으로 저장하기 위한 수단</h4>
상수는 간단히 말해, 재할당이 금지된 변수입니다. 즉, 변수와 같이 선언하고 할당하여 사용할 수 있지만, <br>
재할당이 금지되어져 있습니다. <br>
상수는 final이라는 키워드를 사용해 선언할 수 있으며, 관례적으로 대문자에 _ 를 넣어 구분하는 <br>
SCREAMING_SNAKE_CASE를 사용합니다.
<code>final double CALCULATOR_PI  = 3.14;</code>

<h4>상수를 사용하는 이유</h4>

* 프로그램이 실행되면서 값이 변하면 안되는 경우
    * 프로그래머가 실수로 상수에 값을 재할당하고자 하면 에러가 발생하여 실수를 방지할 수 있습니다.
* 코드 가독성을 높이고 싶은 경우
    * 상수를 사용하면 값을 저장하고 있는 상수명으로 값을 사용할 수 있기 때문에 코드 가독성이 향상됩니다.
* 코드 유지관리를 손쉽게 하고자 하는 경우
    * 여러분들이 계산기 프로그램을 만들었으며, 소스 코드에서 원주율이 필요한 곳에 모두 숫자값 3.14를 <br>
    대로 사용했다고 가정합시다. 만약, 여러분이 계산의 정밀도를 높이기 위해 원주율을 3.14159로 변경해야 한다면, <br>
    기존의 3.14가 사용된 모든 코드를 찾아 일일이 수정해주어야 합니다. <br>
    반면, 상수를 사용하면 상수에 할당할 값만 3.14159로 바꾸어주면 됩니다.

<pre>
    <code>
        // 기존 코드
        final double CALCULATOR_PI  = 3.14;

        // 변경된 코드
        final double CALCULATOR_PI  = 3.14159;
    </code>
</pre>

타입
----

<h4>타입이란?</h4>
타입은 어떤 값의 유형 및 종류를 의미하며, 타입에 따라 **값이 차지하는 메모리 공간의 크기**와, <br>
**값이 저장되는 방식**이 결정됩니다. <br>
<br>
* 값이 차지하는 메모리 공간의 크기
    * 예를 들어, 정수형 타입의 데이터는 4byte, 문자형 타입의 데이터는 1byte입니다.
* 값이 저장되는 방식
    * 타입은 저장하고자 하는 값을 그대로 저장하는 **기본타입**과, 저장하고자 하는 값을 임의의 메모리 공간에 <br>
    저장한 후, 그 메모리 공간의 주소를 저장하는 **참조타입**으로 분류됩니다.

<h4>기본 타입과 참조 타입</h4>

자바의 타입은 실제 값을 의미하는 기본 타입과 어떤 값이 저장된 주소를 값으로 갖는 참조 타입, 두가지의 데이터 타입을 가지고 있습니다. <br>
<br>
* 기본 타입(primitive type)
    * 값을 저장할 때, 데이터의 실제 값이 저장됩니다.
    * 정수 타입(byte, short, int, long), 실수 타입(float, double), 문자 타입(char), 논리 타입(boolean)
* 참조 타입(reference type)
    * 값을 저장할 때, 데이터가 저장된 곳을 나타내는 주소값이 저장됩니다.
    * 객체의 주소를 저장, 8개의 기본형을 제외한 나머지 타입

<pre>
    <code>
        public class Example {
            public static void main(String[] args) {
                int primitive = 1;
                Object reference = new Object();
        
                System.out.println(primitive);
                System.out.println(reference);
            }
        }
    </code>
</pre>

* int primitive = 1;은 의사코드 예제의 기본타입변수 = 1;에 구조적으로 대응됩니다.
* Object reference = new Object();는 의사코드 예제의 참조타입변수 = 객체;에 구조적으로 대응됩니다.
* System.out.println();은 의사코드 예제의 출력(); 메서드와 대응됩니다.

리터럴
------

<h4>리터럴이란?</h4>
프로그래밍에서 리터럴이란 **문자가 가리키는 값 그 자체**를 의미합니다.
<br>

<pre>
    <code>
        class Example {
            public static void main(String[] args) {
                int num; // 변수 선언
                num = 1; // 값 할당
            }
        }
    </code>
</pre>

위 예제에서 num에 할당하고 있는 1이 바로 리터럴입니다.

* float 타입의 변수에 실수형 리터럴을 할당할 때, 리터럴 뒤에 접미사 f를 붙여주어야 합니다.
* long 타입의 변수에 정수형 리터럴을 할당할 때, 리터럴 뒤에 접미사 L을 붙여주어야 합니다.
    * 소문자 l을 붙여도 되지만, 숫자와의 혼동을 방지하기 위해 보통 대문자 L을 사용합니다.

<pre>
    <code>
        float weight = 74.5f;
        final long LIGHT_YEAR = 9460730472580L;

        float = 9460730472580.0F;
        double = 9460730472580.0D;
    </code>
</pre>

정수 타입
---------

정수 타입은 숫자를 나타내는 타입으로, byte, short, int, long 의 총 4개의 타입으로 분류됩니다. <br>
이들은 각각 차지하는 메모리의 크기가 다르며, 그에 따라 나타낼 수 있는 숫자의 범위가 다릅니다. <br>

타입별로 차지하는 메모리 공간의 크기와 표현할 수 있는 범위입니다.

|:타입:|:메모리:|:표현범위:|
|---|---|-----|
|byte|1byte|-128 ~ 127|
|short|2byte|-32,768 ~ 32,767|
|int|4byte|-2,147,483,648 ~ 2,147,483,647|
|long|8byte|-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807|

정수형 리터럴은 아래와 같이 정수형 변수에 할당할 수 있습니다. <br>
이 때, long 타입 리터럴의 경우레는 리터럴 뒤에 접미사 L 또는 <br>
l 을 붙여주어야 합니다. 일반적으로, 순자 1과 혼동을 방지하기 위해 대문자 L을 붙입니다.

<pre>
    <code>
        // 각 데이터 타입의 표현 범위에 맞는 값을 할당하고 있습니다. 
        byte  byteNum  = 123;
        short shortNum = 12345;
        int   intNum   = 123456789;
        long  longNum  = 12345678910L;

        // 각 데이터 타입의 표현 범위에 벗어난 값을 할당하고 있어 에러가 발생합니다. 
        byte  byteNum  = 130;
        short shortNum = 123456;
        int   intNum   = 12345678910;

        // 숫자가 길면 언더바로 구분할 수 있습니다. 
        int   intNum   = 12_345_678_910;
        long  longNum  = 12_345_678_910L;
    </code>
</pre>

<h4>정수형의 오버플로우와 언더플로우</h4>

작성한 코드가 실행중일 때, 어떤 값이 실수로 작성한 코드에 의해 <br>
각 타입의 표현 범위를 넘어서는 경우가 발생할 수 있습니다. <br>

<img src="https://user-images.githubusercontent.com/77485397/209815239-c70f3471-61a2-4eaf-8f3b-1dc7b1ebf51c.png" alt="">

* 오버플로우
    * 자료형이 표현할 수 있는 범위 중 최대값 이상의 값을 표현한 경우 발생합니다.
    * 최대값을 넘어가면 해당 데이터 타입의 최소값으로 값이 순환합니다.
    * 예 : 어떤 값이 byte형이고, byte형의 최대값인 127을 값으로 가지는 경우, 이 값에 1을 더하면 128이 되는게 아니라, 최소값인 -128이 됩니다.

* 언더플로우
    * 자료형이 표현할 수 있는 범위 중 최소값 이하의 값을 표현한 경우 발생합니다.
    * 최소값을 넘어가면 해당 데이터 타입의 최대값으로 값이 순환합니다.
    * 예 : 어떤 값이 byte형이고, byte 형의 최소값인 -128을 값으로 가지는 경우, 이 값에 1을 빼면 -129가 되는게 아니라, 최대값인 127이 됩니다.

<h4>데이터 다입의 크기와 표현 범위</h4>

데이터 타입의 크기와 정수형의 표현 범위 간에 무슨 관련이 있을까요? byte → short → int → long으로 <br>
갈수록 데이터 타입의 크기도 커지고 표현 범위도 커집니다. 즉, 데이터 타입의 크기가 데이터의 표현 범위를 결정합니다. <br>
<br>
컴퓨터는 0과 1로 데이터를 표현합니다. 즉 0과 1로 이루어진 이진수로 데이터를 표현합니다. <br>
이진수 한자리로는 0과 1만 표현할 수 있지만, 이진수를 두 자리, 세 자리로 늘리면 더 많은 데이터를 표현할 수 있습니다. <br>

* 이진수 한 자리 : 0, 1 → 2개
* 이진수 두 자리 : 00, 01, 10, 11 → 4개
* 이진수 세 자리 : 000, 001, 010, 011, 100, 101, 110, 111 → 8개

실수 타입
--------

실수는 소수점을 가지는 값을 의미하며, float 형과 double 형으로 분류됩니다. <br>
<br>
실수형 리터럴은 아래와 같이 사용할 수 있습니다. 이 때,  double 형 리터럴에는 접미사 d 를 붙여도, <br>
붙이지 않아도 되지만, float 형 리터럴에는 반드시 접미사 f 를 붙여주어야 합니다.

<pre>
    <code>
        // float형 리터럴을 float형 변수에 할당
        float num1 = 3.14f;

        // double형 리터럴을 double형 변수에 할당
        double num2 = 3.141592d;
        double num2 = 3.141592;
    </code>
</pre>

 double형은 float형보다 정밀도가 더 높습니다. <br>
 따라서 double형은 float형보다 더 큰 실수를 저장할 수 있고 더 정확하게 저장할 수 있습니다.
 
 <h4>실수형의 오버플로우와 언더플로우</h4>

 실수형에서도 오버플로우와 언더플로우가 발생합니다. 다만, 오버플로우와 언더플로우가 발생했을 때의 결과가 다릅니다. <br>

* 오버플로우
    * 값이 음의 최소 범위 또는 양의 최대 범위를 넘어갔을 때 발생하며, 이 때 값은 무한대가 됩니다.
* 언더플로우
    * 값이 음의 최대 범위 또는 양의 최소 범위를 넘어갔을 때 발생하며, 이 때 값은 0이 됩니다.


논리 타입
--------

논리 타입의 종류는 boolean 형 한가지 뿐입니다. boolean 형은 참 또는 거짓을 저장할 수 있는 데이터 타입으로, <br>
오직 true 혹은 false 를 값으로 가집니다. <br>
<br>
단순히 참과 거짓을 표현하기 위해서는 1bit만 있으면 되지만, JVM이 다룰 수 있는 데이터의 최소 단위가 <br>
1byte 이기 때문에 boolean형은 1byte(8bit)의 크기를 가집니다.

문자 타입
--------

문자 타입은 2byte 크기의 char 형 오직 하나만 있습니다. <br>

문자 타입 변수를 선언하면 해당 변수에 오직 하나의 문자형 리터럴을 저장할 수 있습니다. <br>
<br>
문자형 리터럴을 작성할 때에는 반드시 큰 따옴표가 아닌 작은 따옴표를 사용하여야 합니다. <br>
큰 따옴표를 사용한 리터럴은 문자형이 아니라 문자열 리터럴로 인식되기 때문입니다. 

<pre>
    <code>
        char letter1 = 'a';
        char letter2 = 'ab'; // 에러 : 단 하나의 문자만 할당할 수 있습니다. 
        char letter3 = "a"   // 에러 : 작은 따옴표를 사용해야 합니다. 
    </code>
</pre>

타입 변환
--------

boolean을 제외한 기본 타입 7개는 서로 타입을 변활할 수 있습니다.

<h4>자동 타입 변환</h4>

아래 두 경우에는 타입이 자동으로 변환됩니다.
* 바이트 크기가 작은 타입에서 큰 타입으로 변환할 때 (예 : byte → int)
* 덜 정밀한 타입에서 더 정밀한 타입으로 변환할 때 (예 : 정수 → 실수)
<br>
아래 순서도의 화살표는 화살표를 기준으로 좌측의 타입이 우측의 타입으로 자동으로 변환될 수 있습니다.

<code>byte(1) -> short(2)/char(2) -> int(4) -> long(8) -> float(4) -> double(8)</code>

위의 순서도에서 float은 4byte인데 int와 long보다 더 뒤쪽에 있습니다. <br>
이는 float이 표현할 수 있는 값이 모든 정수형보다 더 정밀하기 때문입니다.

<pre>
    <code>
        // float이 long보다 정밀하므로, 자동으로 타입이 변환됩니다.
        long  longValue  = 12345L;
        float floatValue = longValue;

        System.out.println(floatValue); // 12345.0이 출력됩니다.
    </code>
</pre>

<h4>수동 타입 변환</h4>

차지하는 메모리 용량이 더 큰 타입에서 작은 타입으로는 자동으로 타입이 변환되지 않습니다. <br>
<br>
수동으로 타입을 변환할 때에는 캐스팅 연산자 ()를 사용하며, 캐스팅 연산자의 안에 변환하고자 하는 타입을 적어주면 됩니다.

<pre>
    <code>
        //int 타입으로 선언된 변수 intValue를 더 작은 단위인 byte로 변환합니다.
        int intValue = 128;
        byte byteValue = (byte)intValue;

        System.out.println(byteValue); // -128
    </code>
</pre>

byte형의 표현 범위는 -128 ~ 127이므로, 128을 byte형으로 변환하면 표현 범위를 벗어나게 되어 오버플로우가 발생합니다. <br>
따라서 최종적으로 저장되는 값은 -128이 됩니다.

문자열
======
