---
layout: single
title: "JAVA 객체지향 프로그래밍"
permalink: /eight/
categories:
  - JAVA
toc: true
toc_sticky: true
---

# **상속**

**상속**이란 **기존의 클래스를 재활용하여 새로운 클래스를 작성하는 자바의 문법 요소**를 의미합니다.

두 클래스를 상위 클래스와 하위 클래스로 나누어 상위 클래스의 맴버를 하위 클래스와 공유하는 것을 의미합니다.

이 두 클래스를 서로 상속 관계에 있다고 하며, 하위 클래스는 상위 클래스가 가진 모든 멤버를 상속받게 됩니다.

따라서 **하위 클래스의 멤버 개수는 언제나 상위 클래스의 맴버와 비교했을 대 같거나 많습니다**.

두 클래스 간 상속 관계를 설정할 때 **extends** 키워드를 사용합니다.

![Untitled](JAVA%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%B5%E1%84%92%E1%85%A3%E1%86%BC%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%2067d89824b90c4d0dbb4e0e13b583abfb/Untitled.png)

상속을 사용하는 이유는 코드를 재사용하여 보다 적은 양의 코드로 새로운 클래스를 작성할 수 있어 코드의 중복을 제거할 수 있고, 다형적 표현이 가능하다는 장점이 있습니다.

```jsx
class Parents { }
class Child extends Parents {}
```

**자바에서 상속을 구현하는 방법은 클래스명 다음에 extends 상위 클래스명을 사용하여 정의합니다.**

또한 자바의 객체지향 프로그래밍에서는 **단일 상속**만을 허용합니다.

```
class Person {
    String name;
    int age;

    void learn(){
        System.out.println("공부를 합니다.");
    };

}
class Programmer extends Person { // Person 클래스로부터 상속. extends 키워드 사용 
    String companyName;

    void coding(){
        System.out.println("코딩을 합니다.");
    };
}
public class HelloJava {
    public static void main(String[] args){

        //Person 객체 생성
        Person p = new Person();
        p.name = "김코딩";
        p.age = 24;
        p.learn();
        System.out.println(p.name);

        //Programmer 객체 생성
        Programmer pg = new Programmer();
        pg.name = "박해커";
        pg.age = 26;
        pg.learn(); // Persons 클래스에서 상속받아 사용 가능
        pg.coding(); // Programmer의 개별 기능
        System.out.println(pg.name);
    }
}
// 출력값
공부를 합니다.
김코딩
공부를 합니다.
코딩을 합니다.
박해커
```

## 포함 관계

**포함**은 상속처럼 클래스를 재사용할 수 있는 방법으로,

**클래스의 멤버로 다른 클래스 타입의 참조변수를 선언하는 것**을 의미합니다.

즉, 클래스의 속성 값에 다른 클래스를 선언하여 사용하는 것입니다.

```jsx
public class CompositeEx {
	int number;
	Address address;

	public CompositeEx(int number, Address address){
	    this.number = number;
	    this.address = address;
	}
	
	void printInfo() {
	    System.out.println(number + ": " + address.city + ", " + address.country);
	}
	
	public static void main(String[] args) {
	    Address address1 = new Address("서울", "대한민국");
	    Address address2 = new Address("부산", "대한민국");
	
	    CompositeEx result1 = new CompositeEx(1, address1);
	    CompositeEx result2 = new CompositeEx(2, address2);
	
	    result1.printInfo();
	    result2.printInfo();
	}
}
class Address {
    String city;
    String country;

	public Address(String city, String country) {
	    this.city = city;
	    this.country = country;
	}
}
```

위 코드는 Address 클래스를 속성으로 가지고 사용합니다.

## 메서드 오버라이딩

메서드 오버라이딩은 **상위 클래스로부터 상속받은 메서드와 동일한 이름의 메서드를 재정의하는 것**

을 의미합니다.

```
public class Main {
    public static void main(String[] args) {
        Bike bike = new Bike();
        Car car = new Car();
        MotorBike motorBike = new MotorBike();

        bike.run();
        car.run();
        motorBike.run();
    }
}

class Vehicle {
    void run() {
        System.out.println("Vehicle is running");
    }
}

class Bike extends Vehicle {
    void run() {
        System.out.println("Bike is running");
    }
}

class Car extends Vehicle {
    void run() {
        System.out.println("Car is running");
    }
}

class MotorBike extends Vehicle {
    void run() {
        System.out.println("MotorBike is running");
    }
}
// 출력값
Bike is running
Car is running
MotorBike is running
```

오버라이딩시 세 가지 조건을 만족시켜야 합니다.

1. **메서드의 선언부(메서드 이름, 매개변수, 반환타입)이 상위클래스와 완전히 일치해야한다.**
2. **접근 제어자의 범위가 상위 클래스의 메서드보다 같거나 넓어야 한다.**
3. **예외는 상위 클래스의 메서드보다 많이 선언할 수 없다.**

## super, super()

**super 키워드는 상위클래스의 객체**,

**super()는 상위 클래스의 생성자를 호출하는 것**을 의미합니다.

```
public class Example {
    public static void main(String[] args) {
        SubClass subClassInstance = new SubClass();
        subClassInstance.callNum();
    }
}

class SuperClass {
    int count = 20; // super.count
}

class SubClass extends SuperClass {
    int count = 15; // this.count

    void callNum() {
        System.out.println("count = " + count);
        System.out.println("this.count = " + this.count);
        System.out.println("super.count = " + super.count);
    }
}

// 출력값
count = 15
count = 15
count = 20
```

```
public class Test {
    public static void main(String[] args) {
        Student s = new Student();
    }
}

class Human {
    Human() {
        System.out.println("휴먼 클래스 생성자");
    }
}

class Student extends Human { // Human 클래스로부터 상속
    Student() {
        super(); // Human 클래스의 생성자 호출
        System.out.println("학생 클래스 생성자");
    }
}

// 출력값
휴먼 클래스 생성자
학생 클래스 생성자
```

**모든 생성자의 첫 줄에는 반드시 this() 또는 super() 가 선언되어야 합니다.**

## Object 클래스

Object 클래스는 자바의 클래스 **상속계층도에서 최상위**에 위치한 상위클래스입니다.

따라서 자바의 모든 클래스는 Object 클래스로부터 확장됩니다.

```
class ParentEx {  //  컴파일러가 "extends Object" 자동 추가

}

class ChildEx extends ParentEx {

}
```

위의 예시에서, ParenEx 클래스를 상속받아 ChildEx 클래스를 만들었을 때 상위클래스 ParenEx는

아무것도 상속하고 있지 않기에 컴파일러는 extends Object를 삽입하는 것입니다.

**Object 클래스는 자바 클래스의 상속계층도에 가장 위에 위치하기 때문에 Object 클래스의 멤버들을 자동으로 상속받아 사용**할 수 있습니다.

| 메서드명 | 반환 타입 | 주요 내용 |
| --- | --- | --- |
| toString() | String | 객체 정보를 문자열로 출력 |
| equals(Object obj) | boolean | 등가 비교 연산(==)과 동일하게 스택 메모리값을 비교 |
| hashCode() | int | 객체의 위치정보 관련. Hashtable 또는 HashMap에서 동일 객체여부 판단 |
| wait() | void | 현재 쓰레드 일시정지 |
| notify() | void | 일시정지 중인 쓰레드 재동작 |

Object 클래스의 대표적인 메서드 표입니다.

# 캡슐화
