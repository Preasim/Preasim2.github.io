---
layout: single
title: "JAVA 심화"
permalink: /nine/
categories:
  - JAVA
toc: true
toc_sticky: true
---

# Annotation 애너테이션

에너테이션은 소스 코드가 컴파일되거나 실행될 때에 

컴파일러 및 다른 프로그램에게 필요한 정보를 전달해주는 문법 요소입니다.

```java
public class ExampleClass implements ExampleInterface {
    @Override
    public void example() {

    }
}
```

위 코드에서 보이는 `@Override` 가 바로 애너테이션입니다. 

애너테이션은 `@` 로 시작하며, 클래스, 인터페이스, 필드, 메서드 등에 붙여서 사용할 수 있습니다.

위 코드에서의 `@Override` 는 `example()` 이 추상 메서드를 구현하거나,

상위 클래스의 메서드를 오버라이딩한 메서드라는 것을 **컴파일러에게 알려주는 역할**을 합니다.

JDK 에서 기본적으로 제공하는 애너테이션은 아래의 두 가지로 구분됩니다.

- **표준 애너테이션** : JDK에 내장되어 있는 일반적인 애너테이션
- **메타 애너테이션** : 다른 애너테이션을 정의할 때 사용하는 애너테이션

표준 애너테이션은 `@Override` 와 같이 다른 문법 요소에 붙여서 사용하는 일반적인 애너테이션,

메타 애너테이션은 애너테이션을 직접 정의해서 사용할 때에 사용하는 애너테이션입니다.

애너테이션도 사용자가 직접 정의해서 사용할 수 있으며, 

이러한 애너테이션을 **사용자 정의 애너테이션**이라고 합니다.

## 표준 애너테이션

### @Override

`@Override` 는 메서드 앞에만 붙일 수 있는 애너테이션으로, 

선언한 메서드가 상위 클래스의 메서드를 오버라이딩하거나

추상 메서드를 구현하는 메서드라는 것을 컴파일러에게 알려주는 역할을 수행합니다.

SuperClass의 `example()`를 SubClass에서 오버라이딩 할 때 `@Override`를 붙여주면, 

컴파일러는 SubClass의 `example()`이 상위 클래스의 메서드를 오버라이딩한 것으로 간주합니다.

```java
class SuperClass {
    public void example() {
        System.out.println("example() of SuperClass");
    }
}

class SubClass extends SuperClass {

    @Override
    public void example() {
        System.out.println("example() of SubClass");
    }
}
```

```java
class SuperClass {
    public void example() {
        System.out.println("example() of SuperClass");
    }
}

class SubClass extends SuperClass {

    public void exapmle() { // 메서드 이름에 오타가 있습니다. 
        System.out.println("example() of SubClass");
    }
}
```

위 코드처럼 `@Override` 를 붙이지 않으면 컴파일러는 `example()` 이라는 새로운 메서드를

정의하는 것으로 간주하고 에러를 발생시키지 않습니다.

즉 에러의 원인을 찾아내기 어려워 집니다.

`@Override` 를 사용하면 `example()` 이 오버라이딩 메서드라는 것을 컴파일러가 인지하고,

상위 클래스에 `example()` 이 존재하는지 확인하기 때문에, 이러한 상황을 방지할 수 있습니다.

### @Deprecated

`@Deprecated` 는 기존에 사용하던 기술이 다른 기술로 대체되어 기존 기술을 적용한 코드를 

더 이상 사용하지 않도록 유도하는 경우에 사용합니다.

```java
class OldClass {
	@Deprecated
	private int oldField;

	@Deprecated
	int getOldField() { return oldField; }
}
```

위 코드를 보면 OldClass의 `oldField` 와 `getOldField()` 에 `@Deprecated` 가 붙어 있습니다.

이 때, 다른 클래스에서 OldClass를 인스턴스화 하여 `getOldField()`를 호출하면 취소선이 뜨면서,

에디터에서 경고 메세지를 출력해줍니다.

`**@Deprecated`는 기존의 코드를 다른 코드와의 호환성 문제로 삭제하기 곤란해 남겨두어야 하지만** 

**더 이상 사용하는 것을 권장하지 않을 때에 사용합니다.**

### @SuppressWarnings

컴파일 경고 메시지가 나타나지 않도록 합니다.

경우에 따라서 경고가 발생할 것이 충분히 예상됨에도 묵인해야 할 때 주로 사용합니다.

| 애너테이션 | 설명 |
| --- | --- |
| @SuppressWarnings(”all”) | 모든 경고를 억제 |
| @SuppressWarnings(”deprecation”) | Deprecated 메서드를 사용한 경우에 발생하는 경고를 억제 |
| @SuppressWarnings(”fallthrough”) | switch문에서 break 구문이 없을 때 발생하는 경고를 억제 |
| @SuppressWarnings(”finally”) | finally와 관련된 경고를 억제 |
| @SuppressWarnings(”null”) | null과 관련된 경고를 억제 |
| @SuppressWarnings(”unchecked”) | 검증되지 않은 연산자와 관련된 경고를 억제 |
| @SuppressWarnings(”unused”) | 사용하지 않는 코드와 관련된 경고를 억제 |

### @FunctionalInterface

함수형 인터페이스를 선언할 때, 컴파일러가 함수형 인터페이스의 선언이 바르게 선언되었는지

확인하도록 합니다. 만약 바르게 선언되지 않은 경우, 에러를 발생시킵니다.

참고로, 함수형 인터페이스는 단 하나의 추상 메서드만을 가져야 하는 제약이 있습니다.

```java
@FunctionalInterface
public interface ExampleInterface {
	public abstract void example(); // 단 하나의 추상 메서드
}
```

## 메타 애너테이션

애너테이션을 정의하는 데에 사용되는 애너테이션으로, 애너테이션의 적용 대상 및 유지 기간을

지정하는 데에 사용됩니다.

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.SOURCE)
public @interface Override {  }
```

애너테이션을 정의할 때에는 `@interface` 키워드를 사용하여 정의합니다.

애너테이션 정의부 상단에 `@Target`, `@Retention` 애너테이션이 붙어 있습니다.

이들은 `@Override` 의 적용 대상과 유지 기간을 지정하는 역할을 합니다.

### @Target

애너테이션을 적용할 “**대상**” 을 지정하는 데 사용합니다.

| 대상 타입 | 적용범위 |
| --- | --- |
| ANNOTATION_TYPE | 애너테이션 |
| CONSTRUCTOR | 생성자 |
| FIELD | 필드(멤버변수, 열거형 상수) |
| LOCAL_VARIABLE | 지역변수 |
| METHOD | 메서드 |
| PACKAGE | 패키지 |
| PARAMETER | 매개변수 |
| TYPE | 타입(클래스, 인터페이스, 열거형) |
| TYPE_PARAMETER | 타입 매개변수 |
| TYPE_USE | 타입이 사용되는 모든 대상 |

표에 나와있는 내용이 `@Target` 애너테이션을 사용하여 지정할 수 있는 대상의 타입이며,

모두 java.lang.annotation.ElementType 이라는 열거형에 정의되어 있습니다.

```java
import static java.lang.annotation.ElementType.*; 
//import문을 이용하여 ElementType.TYPE 대신 TYPE과 같이 간단히 작성할 수 있습니다.

@Target({FIELD, TYPE, TYPE_USE})	// 적용대상이 FIELD, TYPE
public @interface CustomAnnotation { }	// CustomAnnotation을 정의

@CustomAnnotation	// 적용대상이 TYPE인 경우
class Main {
    
		@CustomAnnotation	// 적용대상이 FIELD인 경우
    int i;
}
```

위 코드에서는 `@Target({FIELD, TYPE, TYPE_USE})` 를 사용하여, 각각 필드, 타입,

그리고 타입이 사용되는 모든 대상(변수)에 애너테이션이 적용되도록 한 것입니다.

### @Documented

애너테이션에 대한 정보가 **javadoc으로 작성한 문서에 포함되도록 하는 애너테이션 설정**입니다.

자바에서 제공하는 표준 애너테이션과 메타 애너테이션 중 `@Override` 와 `@SuppressWarnings` 를 

제외하고는 모두 `@Documented`가 적용되어 있습니다.

```java
@Documented
@Target(ElementType.Type)
public @interface CustomAnnotation { }
```

### @Inherited

**하위 클래스가 애너테이션을 상속**받도록 합니다.

@Inherited 애너테이션을 상위 클래스에 붙이면, **하위 클래스도 상위 클래스에 붙은 애너테이션들이 동일하게 적용**됩니다.

```java
@Inherited // @SuperAnnotation이 하위 클래스까지 적용
@interface SuperAnnotation{ }

@SuperAnnotation
class Super { }

class Sub extends Super{ } // Sub에 애너테이션이 붙은 것으로 인식
```

### @Retention

특정 **애너테이션 지속 시간**을 결정하는 데 사용합니다.

애너테이션과 관련한 유지 정책의 종류에는 세 가지가 있습니다.

| 유지 정책 | 설명 |
| --- | --- |
| SOURCE | 소스 파일에 존재, 클래스파일에는 존재하지 않음 |
| CLASS | 클래스 파일에 존재, 실행시에 사용불가, 기본값 |
| RUNTIME | 클래스 파일에 존재, 실행시에 사용가능 |

### @Repeatable

**애너테이션을 여러 번 붙일 수 있도록 허용**한다는 의미를 가지고 있습니다.

```java
@Repeatable(Works.class) // Work 애너테이션을 여러 번 반복해서 쓸 수 있게 한다.  
@interface Work{  
    String value();  
}

// Work 애너테이션을 하나의 대상에 여러번 적용하는것이 가능
@Work("코드 업데이트")  
@Work("메서드 오버라이딩")  
class Main{  
	... 생략 ...
}
```

`@Repeatable` 애너테이션은 일반적인 애너테이션과 달리 같은 이름의 애너테이션이 여러번

적용될 수 있기 때문에, 이 애너테이션들을 하나로 묶어주는 애너테이션도 별도로 작성해야 합니다.

## 사용자 정의 애너테이션

사용자 정의 애너테이션은 이름 그대로 **사용자가 직접 애너테이션을 정의**해서 사용하는것 입니다.

애너테이션을 정의하는 방법은 인터페이스를 정의하는 것과 비슷합니다.

```java
@interface 애너테이션명 { // 인터페이스 앞에 @기호만 붙이면 애너테이션을 정의할 수 있습니다. 
	타입 요소명(); // 애너테이션 요소를 선언
}
```

한 가지 유의할 점은, 애너테이션은 java.lang.annotation 인터페이스를 상속받기 때문에

**다른 클래스나 인터페이스를 상속 받을 수 없다는 사실**입니다.

# Lambda 람다

**함수형 프로그래밍 기법을 지원하는 자바의 문법요소**입니다.

메서드를 하나의 식으로 표현한 것으로, 코드를 매우 간결하면서 명확하게 표현할 수 있다는 큰 장점이 있습니다.

```java
//기존 메서드 표현 방식
void sayhello() {
	System.out.println("HELLO!")
}

//위의 코드를 람다식으로 표현한 식
() -> System.out.println("HELLO!")
```

람다식에서는 **기본적으로 반환타입과 이름을 생략**할 수 있다는 점입니다.

따라서 람다함수를 종종 이름이 없는 함수, 즉 **익명 함수(anonymous function)**라 부르기도 합니다.

람다식의 예시 코드입니다.

```java
// 기존 방식
void example1() {
	System.out.println(5);
}

// 람다식
() -> {System.out.println(5);}
```

```java
void example3(String str) {
	System.out.println(str);
}

// 람다식
(String str) -> {System.out.println(str);}
```

이 외에도 **특정 조건이 충족되면 람다식을 더욱 축약하여 표현**할 수 있습니다.

```java
// 기존 방식
int sum(int num1, int num2) {
	return num1 + num2;
}

// 람다식
(int num1, int num2) -> num1 + num2
// 실행문이 두 개 이상인 경우 중괄호 생략 X
```

메서드 바디에 실행문이 하나만 존재할 때 중괄호와 return문을 생략할 수 있습니다.

이 경우, 세미콜론까지 생략해야 합니다.

매개변수 타입을 함수형 인터페이스를 통해 유추할 수 있는 경우에는 매개변수의 타입을 생략할 수 있습니다.

```jsx
(num1, num2) -> num1 + num2
```

## 함수형 인터페이스

자바에서 함수는 반드시 클래스 안에서 정의되어야 하기 때문에 메서드가 독립적으로 있을 수 없고

반드시 클래스 객체를 먼저 생성한 후 생성한 객체로 메서드를 호출해야 합니다.

**람다식 또한 객체**입니다. **정확히 이름이 없기 때문에 익명 객체**라 할 수 있습니다.

익명 객체는 익명 클래스를 통해 만들 수 있는데, **익명 클래스**란 **객체의 선언과 생성을 동시에 하여 오직 하나의 객체를 생성하고, 단 한번만 사용되는 일회용 클래스**입니다.

```java
// sum 메서드 람다식
(num1, num2) -> num1 + num2

// 람다식을 객체로 표현
new Object() {
	int sum(int num1, int num2) {
		return num1 + num1;
	}
}
// 생성과 선언을 한번에 할 수 있음
```

람다식이 객체면, 이 객체에 접근하고 사용하기 위한 참조변수가 필요합니다.

그런데 기존에 객체를 생성할 때 만들었던 `Object` 클래스에는 `sum` 라는 메서드가 없기 때문에,

`Object` 타입의 참조변수에 담는다고 하더라도 `sum` 메서드를 사용할 수 없습니다.

```java
public class LamdaExample1 {
    public static void main(String[] args) {

				// 람다식 Object obj = (num1, num2) -> num1 + num2; 로 대체 가능
				Object obj = new Object() {
						int sum(int num1, int num2) {
                return num1 + num1;
            }
				};

        obj.sum(1, 2);
		}
}

출력 결과
java: cannot find symbol
  symbol:   method sum(int,int)
  location: variable obj of type java.lang.Object
```

위의 코드에서 익명 객체를 생성하여 참조변수 `obj` 에 담아준다 하더라도 `sum` 메서드를 사용할 수 있는 방법이 없습니다.

이 같은 문제를 해결하기 위해 사용하는 문법 요소가 **함수형 인터페이스**라 할 수 있습니다.

즉, **기존의 인터페이스 문법을 활용하여 람다식을 다루는것** 입니다.

함수형 인터페이스에는 **단 하나의 추상 메서드**만 선언될 수 있는데, 이는 **람다식과 인터페이스의**

**메서드가 1:1로 매칭**되어야 하기 때문입니다.

이제 위의 예제에서 직면했던 문제를 함수형 인터페이스를 적용하여 풀어보도록 하겠습니다.

```java
public class LamdaExample1 {
    public static void main(String[] args) {
		   /* Object obj = new Object() {
            int sum(int num1, int num2) {
                return num1 + num1;
            }
        };
			*/ 
		ExampleFunction exampleFunction = (num1, num2) -> num1 + num2;
		System.out.println(exampleFunction.sum(10,15));
}

@FunctionalInterface // 컴파일러가 인터페이스가 바르게 정의되었는지 확인하도록 합니다. 
interface ExampleFunction {
		int sum(int num1, int num2);
}

// 출력값
25
```

### 매개변수와 리턴값이 없는 람다식

매개변수와 리턴값이 없는 추상 메서드를 가진 함수형 인터페이스가 있다고 가정해보겠습니다.

```java
@FunctionalInterface
public interface MyFunctionalInterface {
    void accept();
}
```

이 인터페잇흐를 타겟 타입으로 갖는 람다식은 다음과 같은 형태로 작성해야 합니다.

람다식에서 매개변수가 없는 이유는 `accept()` 가 매개변수를 가지지 않기 때문입니다.

```java
MyFunctionalInterface example = () -> { ... };
// example.accept();
```

람다식이 대입된 인터페이스의 참조 변수는 위의 주석과 같이 `accept()` 를 호출할 수 있습니다.

아래 코드를 보면서 매개변수와 리턴값이 없는 경우의 람다식을 이해합니다.

```java
@FunctionalInterface
interface MyFunctionalInterface {
    void accept();
}

public class MyFunctionalInterfaceExample {

		public static void main(String[] args) throws Exception {

				MyFunctionalInterface example = () -> System.out.println("accept() 호출");
				example.accept();

		}
}

// 출력값
accept() 호출
```

### 매개변수가 있는 람다식

```java
@FunctionalInterface
public interface MyFunctionalInterface {
    void accept(int x);
}
// 매개 변수가 있고 리턴값이 없는 추상 메서드를 사진 함수형 인터페이스

public class MyFunctionalInterfaceExample {

    public static void main(String[] args) throws Exception {

        MyFunctionalInterface example;
        example = (x) -> {
            int result = x * 5;
            System.out.println(result);
        };
        example.accept(2);

        example = (x) -> System.out.println(x * 5);
        example.accept(2);
    }
}

// 출력값
10
10
```

매개변수가 한 개인 이유는 추상메서드 `accept()` 가 매개변수를 하나만 가지기 때문입니다.

위의 예시와 같이 매개값으로 2를 주면 람다식의 x변수에 2가 대입되고, x는 중괄호에서 사용됩니다.

### 리턴값이 있는 람다식

```java
@FunctionalInterface
public interface MyFunctionalInterface {
    int accept(int x, int y);
}
//매개 변수와 리턴값을 가지는 추상 메서드를 포함하는 함수형 인터페이스

public class MyFunctionalInterfaceExample {

    public static void main(String[] args) throws Exception {

        MyFunctionalInterface example;

	      example = (x, y) ->  x + y;
				//return문만 있을 경우, 중괄호 {}와 return문 생략가능
        int result3 = example.accept(2, 5);
        System.out.println(result3);
    }

    public static int sum(int x, int y){
        return x + y;
    }
}
//출력값
7
```

매개값으로 2와 5를 주면 람다식의 x변수에 2 y변수에 5가 대입되고 x, y는 중괄호에서 사용됩니다.
